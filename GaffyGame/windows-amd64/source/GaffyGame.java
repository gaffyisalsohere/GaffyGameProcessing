/* autogenerated by Processing revision 1293 on 2024-03-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class GaffyGame extends PApplet {

//GAFFYGAME ALPHA
//
//MENU CONTROLS: W and S move cursor, J selects, K backs out of credits
//GAME CONTROLS: A and D move left and right, J jumps, hold K to hold small boxes, L hammers.

//sfx
SoundFile jump;
SoundFile bonk;
SoundFile coin;
SoundFile shatter;
SoundFile slam;
SoundFile hurt;
SoundFile oneup;
SoundFile respawn;
//mus
SoundFile title;
SoundFile lv1;
SoundFile lv2;
SoundFile lv3;
SoundFile gameend;
SoundFile lclear;
TopLogic t;

public void setup()
{

  //for reference: "d" effects the "grid" objects are put on; all object coordinate and scale grids are divisible by d by design, except when to patch up AA jank.
  //"d" takes this meaning on all subsequent pages, by the way.
  t = new TopLogic();
  /* size commented out by preprocessor */; //256*224, 3x upscale. my game is heavily influenced by SNES
  frameRate(60);
  noCursor();
  noStroke();
  //sfx define
  jump = new SoundFile(this, "jump.wav");
  bonk = new SoundFile(this, "bonk.wav");
  coin = new SoundFile(this, "coin.wav");
  shatter = new SoundFile(this, "shatter.wav");
  slam = new SoundFile(this, "slam.wav");
  hurt = new SoundFile(this, "hurt.wav");
  oneup = new SoundFile(this, "1up.mp3");
  respawn = new SoundFile(this, "respawn.wav");
  //mus define
  title = new SoundFile(this, "title.mp3");
  lv1 = new SoundFile(this, "l1.mp3");
  lv2 = new SoundFile(this, "l2.mp3");
  lv3 = new SoundFile(this, "l3.mp3");
  lclear = new SoundFile(this, "lclear.mp3");
  gameend = new SoundFile(this, "gameover.mp3");
  t.vernum = "1.24.03.03";
}


public void keyPressed()
{
  t.p1.keyStart(key);
  t.menu.keyStart(key);
}


public void keyReleased()
{
  t.p1.keyStop(key);
  t.menu.keyStop(key);
}
public void draw()
{
  t.GameLoop();
}
class Boulder
{
  CollideBoulder collide;
  float xPos, yPos, xVelocity, yVelocity, gravity;
  int d, rolling;
  Boulder(float x, float y)
  {
    xPos = x;    //Horizontal Position
    yPos = y;    //Vertical Position
    d = 3;
    gravity = 0.15f;
  }
  public void Render()
  {
    yPos = (yPos + (yVelocity));     //bad physics sim
    yVelocity = yVelocity + gravity;
    if (yVelocity >=10)
    {
      yVelocity = 10;
    }
    xPos = xPos+xVelocity;
    fill(135);
    ellipse(xPos*d, (yPos-24)*d, 48*d, 48*d);
    if (t.p1.hammerTime > 0 && t.p1.dir == 0)
    {
      if ((xPos > t.p1.hammerHitX-(96)) && ((xPos+(48) < t.p1.hammerHitX+(96))))
      {
        if (yPos-24 > t.p1.hammerHitY -(96) && (yPos+(24) < t.p1.hammerHitY+(96)))
        {
          rolling = 1;
          //println("hit! left");
          xVelocity = -1;
        }
      }
    }
    if (t.p1.hammerTime > 0 && t.p1.dir == 1)
    {
      if ((xPos > t.p1.hammerHitX-(96)) && ((xPos+(48) < t.p1.hammerHitX+(96))))
      {
        if (yPos-24 > t.p1.hammerHitY -(96) && (yPos+(24) < t.p1.hammerHitY+(96)))
        {
          rolling = 2;
          //println("hit! right");
          xVelocity = 1;
        }
      }
    }
    if (((xPos) < t.p1.xPos && (xPos + 32) > t.p1.xPos) && ((yPos - 24 < t.p1.yPos) && (yPos + 24  >= t.p1.yPos))) //hit a left wall?
    {
      if (rolling ==2 && t.p1.iframe == 0)
      {
        t.p1.iframe = 60;
        t.p1.yPos = t.p1.yPos-1;
        t.p1.yVelocity = -1;
        t.hp -= 1;
      }
      t.p1.xPos = (xPos + 32); //stop
      //println("left");
    }

    if (((xPos-32 < t.p1.xPos && (xPos) > t.p1.xPos) && ((yPos  - 24 < t.p1.yPos) && (yPos + 24  >= t.p1.yPos)))) //hit a right wall?
    {
      if (rolling ==1 && t.p1.iframe == 0)
      {
        t.p1.iframe = 60;
        t.p1.yPos = t.p1.yPos-1;
        t.p1.yVelocity = -1;
        t.hp -= 1;
      }
      t.p1.xPos = (xPos - 32); //stop
      //println("right");
    }

    if (((yPos-68 < t.p1.yPos && (yPos - 40) > t.p1.yPos) && ((xPos  - 28 < t.p1.xPos) && (xPos + 28 >  t.p1.xPos)))) //hit floor?
    {
      t.p1.yPos = (yPos - 68); //stop, *and* properly reset jumps
      t.p1.yVelocity = 0;
      t.p1.jumpFlag = 1;
      //println("floor");
    }
  }
}
class Box
{
  GroundAll ground;
  CollisionSolids collide;
  boolean isGrabbed, smashed, grounded, painful, sound;
  float xPos, yPos, yVelocity, xSpeed, gravity;
  int d, xScale, yScale, Scale, id, testvar;
  Box(float x, float y, int s, int i)
  {

    Scale = s;
    xScale = Scale;
    yScale = Scale;
    xPos = x;
    yPos = y;
    id = i;
    smashed = false;
  }


  public void Render()
  {
    d=3;

    if (smashed == false)
    {//DRAW A BOX
      noStroke();
      fill(0xFF443A2C);
      rect(xPos*d, yPos*d, Scale*(16*d), Scale*(16*d));
      fill(0xFF867156);
      rect(xPos*d+(1*Scale*d), yPos*d+(1*Scale*d), Scale*(14*d), Scale*(14*d));
      fill(0xFF60513E);
      rect(xPos*d+(2*Scale*d), yPos*d+(2*Scale*d), Scale*(12*d), Scale*(12*d));
      fill(0xFF867156);
      rect(xPos*d+(3*Scale*d), yPos*d+(3*Scale*d), Scale*(10*d), Scale*(10*d));
      fill(0xFF60513E);
      quad((xPos*d+(3*Scale*d)), yPos*d+(4*Scale*d), (xPos*d+(4*Scale*d)), yPos*d+(3*Scale*d), (xPos*d+(13*Scale*d)), yPos*d+(12*Scale*d), (xPos*d+(12*Scale*d)), yPos*d+(13*Scale*d));
      rect(xPos*d+(3*Scale*d), yPos*d+(3*Scale*d), (d*Scale), (d*Scale));
      rect(xPos*d+(12*Scale*d), yPos*d+(12*Scale*d), (d*Scale), (d*Scale));
    }
  }
  public void boxLogic()
  {
    if (smashed == true && sound == false)
    {
      shatter.play();
      sound = true;
    }
    if (smashed == false)
    {
      gravity = 0.15f;
      collide = new CollisionSolids(xPos, yPos, xScale*16, yScale*16);
      if (isGrabbed == false || Scale > 1)
      {
        collide.Collide();
        yPos = (yPos + (yVelocity));     //bad physics sim
        yVelocity = yVelocity + gravity;
        if (yVelocity >=10)
        {
          yVelocity = 10;
        }
      }
      //if (t.boulder.rolling !=0)
      {
        if ((xPos > t.boulder.xPos-(16*Scale*2)) && ((xPos+(Scale*16) < t.boulder.xPos+(16*Scale*2))))
        {
          if (yPos > t.boulder.yPos -(16*Scale*2) && (yPos+(Scale*16) < t.boulder.yPos+(16*Scale*2)-4))
          {
            smashed = true;
            t.score += 50;
            //println("hit!");
          }
        }
      }
      //t.p1.hammer logic
      if (t.p1.hammerTime > 0)
      {
        if ((xPos > t.p1.hammerHitX-(16*Scale*2)) && ((xPos+(Scale*16) < t.p1.hammerHitX+(16*Scale*2))))
        {
          if (yPos > t.p1.hammerHitY -(16*Scale*2) && (yPos+(Scale*16) < t.p1.hammerHitY+(16*Scale*2)))
          {
            smashed = true;
            t.score += 50;
            //println("hit!");
          }
        }
      }
      //grab logic
      if (t.p1.isGrabbing == false)
      {
        isGrabbed = false;
        xPos = xPos + xSpeed;

        if (xPos < 0)
        {
          xPos = 0;
        }
        if (xPos > 1008)
        {
          xPos = 1008;
        }
      }
      if ((t.p1.isGrabbing == true && Scale == 1) && (t.p1.grabbingID == 0 || t.p1.grabbingID == id))
      {
        if (xPos >= t.p1.grabX && (xPos <= t.p1.grabX+(16*Scale)))
        {
          if (yPos >= t.p1.grabY && (yPos <= t.p1.grabY+(16*Scale)))
          {
            isGrabbed = true;
          }
        }
      }
      if (isGrabbed == true)
      {
        painful = true;
        if (t.p1.keya == true)
        {
          xSpeed = -2;
          yVelocity = -0.5f;
        }
        if (t.p1.keyd == true)
        {
          xSpeed = 2;
          yVelocity = -0.5f;
        }
        if (t.p1.keyw == true)
        {
          yVelocity = -5;
          xSpeed = 0;
        }
        id = t.p1.grabbingID;
        xPos = t.p1.grabX;
        yPos = t.p1.grabY;
      }
    }
    if (t.levelID == 1)
    {
      for (int i = 0; i < t.l1.ground.grounds.length; i++) //collider, modified from player collider;
      {
        if (((t.l1.ground.grounds[i].xPos + t.l1.ground.grounds[i].xScale-(16*Scale)) < xPos && (t.l1.ground.grounds[i].xPos + t.l1.ground.grounds[i].xScale) > xPos) && ((t.l1.ground.grounds[i].yPos - (16*Scale) < yPos) && (t.l1.ground.grounds[i].yPos + t.l1.ground.grounds[i].yScale  >= yPos))) //hit a left wall?
        {
          xPos = (t.l1.ground.grounds[i].xPos + t.l1.ground.grounds[i].xScale); //stop
          xSpeed = 0;
        }
        if (((t.l1.ground.grounds[i].xPos-(16*Scale) < xPos && (t.l1.ground.grounds[i].xPos) > xPos) && ((t.l1.ground.grounds[i].yPos  - (16*Scale) < yPos) && (t.l1.ground.grounds[i].yPos + t.l1.ground.grounds[i].yScale  >= yPos)))) //hit a right wall?
        {
          xPos = (t.l1.ground.grounds[i].xPos -(16*Scale));
          xSpeed = 0;//stop
        }
        if ((((t.l1.ground.grounds[i].yPos) < yPos && (t.l1.ground.grounds[i].yPos + t.l1.ground.grounds[i].yScale+16) > yPos) && ((t.l1.ground.grounds[i].xPos < xPos) && (t.l1.ground.grounds[i].xPos + xScale > xPos)))) //hit ceiling?
        {
          yPos = (t.l1.ground.grounds[i].yPos + t.l1.ground.grounds[i].yScale + 18); //stop, *and* properly reset jumps
          yVelocity = 3;
          println(3);
        }
        if (((t.l1.ground.grounds[i].yPos-(16*Scale) < yPos && (t.l1.ground.grounds[i].yPos) > yPos) && ((t.l1.ground.grounds[i].xPos  - 4 < xPos) && (t.l1.ground.grounds[i].xPos + 4 + t.l1.ground.grounds[i].xScale >  xPos)))) //hit floor?
        {
          yPos = (t.l1.ground.grounds[i].yPos - (16*Scale)); //stop, *and* properly reset jumps
          yVelocity = 0;
          xSpeed=0;
          painful = false;
        }
      }
    }
    if (t.levelID == 2)
    {
      for (int i = 0; i < t.l2.ground.grounds.length; i++) //collider, modified from player collider;
      {
        if (((t.l2.ground.grounds[i].xPos + t.l2.ground.grounds[i].xScale-(16*Scale)) < xPos && (t.l2.ground.grounds[i].xPos + t.l2.ground.grounds[i].xScale) > xPos) && ((t.l2.ground.grounds[i].yPos - (16*Scale) < yPos) && (t.l2.ground.grounds[i].yPos + t.l2.ground.grounds[i].yScale  >= yPos))) //hit a left wall?
        {
          xPos = (t.l2.ground.grounds[i].xPos + t.l2.ground.grounds[i].xScale); //stop
          xSpeed = 0;
        }
        if (((t.l2.ground.grounds[i].xPos-(16*Scale) < xPos && (t.l2.ground.grounds[i].xPos) > xPos) && ((t.l2.ground.grounds[i].yPos  - (16*Scale) < yPos) && (t.l2.ground.grounds[i].yPos + t.l2.ground.grounds[i].yScale  >= yPos)))) //hit a right wall?
        {
          xPos = (t.l2.ground.grounds[i].xPos -(16*Scale));
          xSpeed = 0;//stop
        }
        if ((((t.l2.ground.grounds[i].yPos) < yPos && (t.l2.ground.grounds[i].yPos + t.l2.ground.grounds[i].yScale+16) > yPos) && ((t.l2.ground.grounds[i].xPos < xPos) && (t.l2.ground.grounds[i].xPos + xScale > xPos)))) //hit ceiling?
        {
          yPos = (t.l2.ground.grounds[i].yPos + t.l2.ground.grounds[i].yScale + 18); //stop, *and* properly reset jumps
          yVelocity = 3;
          println(3);
        }
        if (((t.l2.ground.grounds[i].yPos-(16*Scale) < yPos && (t.l2.ground.grounds[i].yPos) > yPos) && ((t.l2.ground.grounds[i].xPos  - 4 < xPos) && (t.l2.ground.grounds[i].xPos + 4 + t.l2.ground.grounds[i].xScale >  xPos)))) //hit floor?
        {
          yPos = (t.l2.ground.grounds[i].yPos - (16*Scale)); //stop, *and* properly reset jumps
          yVelocity = 0;
          xSpeed=0;
          painful = false;
        }
      }
    }
    if (t.levelID == 3)
    {
      for (int i = 0; i < t.l3.ground.grounds.length; i++) //collider, modified from player collider;
      {
        if (((t.l3.ground.grounds[i].xPos + t.l3.ground.grounds[i].xScale-(16*Scale)) < xPos && (t.l3.ground.grounds[i].xPos + t.l3.ground.grounds[i].xScale) > xPos) && ((t.l3.ground.grounds[i].yPos - (16*Scale) < yPos) && (t.l3.ground.grounds[i].yPos + t.l3.ground.grounds[i].yScale  >= yPos))) //hit a left wall?
        {
          xPos = (t.l3.ground.grounds[i].xPos + t.l3.ground.grounds[i].xScale); //stop
          xSpeed = 0;
        }
        if (((t.l3.ground.grounds[i].xPos-(16*Scale) < xPos && (t.l3.ground.grounds[i].xPos) > xPos) && ((t.l3.ground.grounds[i].yPos  - (16*Scale) < yPos) && (t.l3.ground.grounds[i].yPos + t.l3.ground.grounds[i].yScale  >= yPos)))) //hit a right wall?
        {
          xPos = (t.l3.ground.grounds[i].xPos -(16*Scale));
          xSpeed = 0;//stop
        }
        if ((((t.l3.ground.grounds[i].yPos) < yPos && (t.l3.ground.grounds[i].yPos + t.l3.ground.grounds[i].yScale+16) > yPos) && ((t.l3.ground.grounds[i].xPos < xPos) && (t.l3.ground.grounds[i].xPos + xScale > xPos)))) //hit ceiling?
        {
          yPos = (t.l3.ground.grounds[i].yPos + t.l3.ground.grounds[i].yScale + 18); //stop, *and* properly reset jumps
          yVelocity = 3;
          println(3);
        }
        if (((t.l3.ground.grounds[i].yPos-(16*Scale) < yPos && (t.l3.ground.grounds[i].yPos) > yPos) && ((t.l3.ground.grounds[i].xPos  - 4 < xPos) && (t.l3.ground.grounds[i].xPos + 4 + t.l3.ground.grounds[i].xScale >  xPos)))) //hit floor?
        {
          yPos = (t.l3.ground.grounds[i].yPos - (16*Scale)); //stop, *and* properly reset jumps
          yVelocity = 0;
          xSpeed=0;
          painful = false;
        }
      }
    }
  }
}
class BoxAll
{
  Box[] boxes;
  Box b1, b2, b3, b4;
  int level;
  BoxAll(int l)
  {
    level = l;
    //define boxes ahead of time for control

    b1 = new Box (160, 416, 2, 1); //1-1 boxes
    b2 = new Box (80, 432, 1, 2);
    b3 = new Box (128, 432, 1, 3);

    b4 = new Box(384, 368, 896, 32);
  }
  public void LevelInit()
  { //arrayify box for collision
    boxes = new Box[1];
    for (int i = 0; i < boxes.length; i++)
    {
      boxes[i] = new Box(-128, -128, 16, 16);
    }
    if (level == 1)
    {
      boxes = (Box[])  append(boxes, b1);
      boxes = (Box[])  append(boxes, b2);
      boxes = (Box[])  append(boxes, b3);
      boxes = (Box[])  append(boxes, b4);
    }
    if (level == 2)
    {
    }
    if (level == 3)
    {
    }
  }
  public void Render()
  {
    for (int i = 1; i < boxes.length; i++)
    {
      boxes[i].boxLogic();
      boxes[i].Render();
    }
  }
}
class BusStop
{
  float xPos, yPos;
  int d;
  BusStop(float x, float y)
  {
    xPos = x;    //Horizontal Position
    yPos = y;    //Vertical Position
    d=3;
  }
  public void Render()
  {
    fill(0xFFBB5244);
    rect((xPos+16)*d, yPos*d, 112*d, 80*d, 8*d);
    rect((xPos+6)*d, (yPos-16)*d, 4*d, 128*d);
    fill(0xFF703129);
    rect((xPos+16)*d, (yPos+16)*d, 112*d, 80*d);

    circle((xPos+8)*d, (yPos-16)*d, 16*d);
    fill(0xFFFCC900);
    arc((xPos+8)*d, (yPos-16)*d, 16*d, 16*d, 0.25f, (PI-0.25f), CHORD);
    if ((t.p1.xPos > xPos+6) && (t.p1.yPos > yPos))
    {
      if (t.levelClear == false)
      {
        t.levelClear = true;
      }
    }
  }
}
class Cloud
{ //modified from Assign 2's clouds. Now they finally scroll!
  float xPos, yPos, xSpeed;
  int d;
  Cloud(float x, float y, float s)
  {
    xPos = x;    //Horizontal Position
    yPos = y;    //Vertical Position
    xSpeed = s;  //Scrolling Speed
  }
  public void Render()
  {
    //Draw Clouds
    d=3;
    noStroke();
    fill(0xFF749093);
    ellipse(xPos-(8*d), yPos-(3*d), 32*d, 16*d);   // 4 dark ellipse
    ellipse(xPos+(8*d), yPos-(3*d), 32*d, 16*d);
    fill(0xFF8CAFB2);
    ellipse(xPos-(12*d), yPos, 32*d, 16*d);     // 2 mid ellipse
    ellipse(xPos+(12*d), yPos, 32*d, 16*d);
    fill(0xFFB3CACB);
    ellipse(xPos, yPos, 32*d, 16*d);       // 2 light ellipse
    ellipse(xPos, yPos-(3*d), 24*d, 24*d);     // 1 taller
    //Move Clouds
    xPos += xSpeed;
    if (xPos <(-64*d))
    {
      xPos = 306*d;
    }
    if (xPos > (320*d))
    {
      xPos = -50*d;
    }
  }
}
class CollideBoulder
{

  float xPos, yPos, xScale, yScale;
  int d;
  CollideBoulder(float x, float y, float xs, float ys)
  {
    xPos = x;
    yPos = y;
    xScale = xs;
    yScale = ys;
  }
  public void Collide()
  {


    d=3;
    fill(255); //draw test solid
    //rect(xPos*d, yPos*d, xScale*d, yScale*d);
    if (((xPos + xScale) < t.boulder.xPos && (xPos +24+ xScale) > t.boulder.xPos) && ((yPos +4 < t.boulder.yPos) && (yPos + yScale  >= t.boulder.yPos))) //hit a left wall?
    {
      t.boulder.xPos = (xPos + xScale+24); //stop
      t.boulder.xVelocity = 0;

    }
    if (((xPos-24 < t.boulder.xPos && (xPos) > t.boulder.xPos) && ((yPos +4< t.boulder.yPos) && (yPos + yScale  >= t.boulder.yPos)))) //hit a right wall?
    {
      t.boulder.xPos = (xPos -24); //stop
      t.boulder.xVelocity = 0;

    }
    if (((yPos < t.boulder.yPos && (yPos + yScale+4) > t.boulder.yPos) && ((xPos  - 4 < t.boulder.xPos) && (xPos + 4 + xScale >  t.boulder.xPos)))) //hit floor?
    {
      t.boulder.yPos = (yPos); //stop, *and* properly reset jumps
      t.boulder.yVelocity = 0;

      //t.boulder.jumpFlag = 1;
    }
  }
}
class Hitbox
{
  BoxAll boxes;
  float xPos, yPos, xScale, yScale;
  int d;
  boolean dead, safe, painful;
  Hitbox(float x, float y, float xs, float ys)
  {
    xPos = x;
    yPos = y;
    xScale = xs;
    yScale = ys;
    dead = false;
  }
  public void Collide()
  {


    d=3;
    fill(255); //draw test solid
    //rect(xPos*d, yPos*d, xScale*d, yScale*d);
    if (t.p1.iframe == 0) //don't hit again if recovering
    {
      if (((xPos + xScale) < t.p1.xPos && (xPos +8+ xScale) > t.p1.xPos) && ((yPos - 16 < t.p1.yPos) && (yPos + yScale  >= t.p1.yPos))) //bumped left?
      {
        t.p1.iframe = 60;

        t.p1.yPos = t.p1.yPos-1;
        t.p1.yVelocity = -1;
        t.hp -= 1;
      }
      if (((xPos-8 < t.p1.xPos && (xPos) > t.p1.xPos) && ((yPos  - 16 < t.p1.yPos) && (yPos + yScale  >= t.p1.yPos)))) //bumped right?
      {
        t.p1.iframe = 60;

        t.p1.yPos = t.p1.yPos-1;
        t.p1.yVelocity = -1;
        t.hp -= 1;
      }
    }
    if (dead == false)
    {
      if (((((yPos-20 < t.p1.yPos && (yPos+yScale) > t.p1.yPos) && ((xPos  - 4 < t.p1.xPos) && (xPos + 4 + xScale >  t.p1.xPos))) && t.p1.jumpFlag == 0)) && safe == true) //jumped on?
      {
        t.p1.yPos = (yPos - 20); //bounce off, kill the enemy
        t.p1.yVelocity = -.3f;
        dead = true;
        t.score += 100;
      }
      if ((t.p1.hammerTime>0) && ((yPos-20 < t.p1.hammerHitY && (yPos+yScale) > t.p1.hammerHitY) && (xPos  - 16*d < t.p1.hammerHitX) && (xPos + xScale >  t.p1.hammerHitX)))
      {
        dead = true;
        t.score += 100;
      }
      if ((xPos > t.boulder.xPos-(20)) && ((xPos+(20) < t.boulder.xPos+(20))))
      {
        if (yPos > t.boulder.yPos -(20) && (yPos+(20) < t.boulder.yPos+(20)))
        {
          dead = true;
          t.score += 100;
          //println("hit!");
        }
      }
      if (t.levelID == 1)
      {
        for (int i = 1; i < t.l1.boxes.boxes.length; i++)
        {
          if ((((yPos-20 < t.l1.boxes.boxes[i].yPos && (yPos+yScale) > t.l1.boxes.boxes[i].yPos) && ((xPos  - 4 < t.l1.boxes.boxes[i].xPos) && (xPos + 4 + xScale >  t.l1.boxes.boxes[i].xPos)))) && t.l1.boxes.boxes[i].painful == true)
          {
            dead = true;
            t.score += 100;
            t.l1.boxes.boxes[i].smashed = true;
          }
        }
      }
      if (t.levelID == 2)
      {
        for (int i = 1; i < t.l2.boxes.boxes.length; i++)
        {
          if ((((yPos-20 < t.l2.boxes.boxes[i].yPos && (yPos+yScale) > t.l2.boxes.boxes[i].yPos) && ((xPos  - 4 < t.l2.boxes.boxes[i].yPos) && (xPos + 4 + xScale >  t.l2.boxes.boxes[i].yPos))))&& t.l2.boxes.boxes[i].painful == true)
          {
            dead = true;
            t.score += 100;
            t.l2.boxes.boxes[i].smashed = true;
          }
        }
      }
      if (t.levelID == 3)
      {
        for (int i = 1; i < t.l3.boxes.boxes.length; i++)
        {
          if ((((yPos-20 < t.l3.boxes.boxes[i].yPos && (yPos+yScale) > t.l3.boxes.boxes[i].yPos) && ((xPos  - 4 < t.l3.boxes.boxes[i].yPos) && (xPos + 4 + xScale >  t.l3.boxes.boxes[i].yPos))))&& t.l3.boxes.boxes[i].painful == true)
          {
            dead = true;
            t.score += 100;
            t.l3.boxes.boxes[i].smashed = true;
          }
        }
      }
    }
  }
}
class CollisionSolids
{

  float xPos, yPos, xScale, yScale;
  int d;
  CollisionSolids(float x, float y, float xs, float ys)
  {
    xPos = x;
    yPos = y;
    xScale = xs;
    yScale = ys;
  }
  public void Collide()
  {


    d=3;
    fill(255); //draw test solid
    //rect(xPos*d, yPos*d, xScale*d, yScale*d);
    if (((xPos + xScale) < t.p1.xPos && (xPos +8+ xScale) > t.p1.xPos) && ((yPos - 16 < t.p1.yPos) && (yPos + yScale  >= t.p1.yPos))) //hit a left wall?
    {
      t.p1.xPos = (xPos + xScale + 8); //stop
    }
    if (((xPos-8 < t.p1.xPos && (xPos) > t.p1.xPos) && ((yPos  - 16 < t.p1.yPos) && (yPos + yScale  >= t.p1.yPos)))) //hit a right wall?
    {
      t.p1.xPos = (xPos - 8); //stop
    }
    if ((((yPos+16) < t.p1.yPos && (yPos + yScale+12) > t.p1.yPos) && ((xPos < t.p1.xPos) && (xPos + xScale > t.p1.xPos)))) //hit ceiling?
    {
      t.p1.yPos = (yPos + yScale + 14); //stop, *and* properly reset jumps
      t.p1.yVelocity = 3;
    }
    if (((yPos-20 < t.p1.yPos && (yPos + yScale+4) > t.p1.yPos) && ((xPos  - 4 < t.p1.xPos) && (xPos + 4 + xScale >  t.p1.xPos)))) //hit floor?
    {
      t.p1.yPos = (yPos - 20); //stop, *and* properly reset jumps
      t.p1.yVelocity = 0;
      t.p1.jumpFlag = 1;
    }
  }
}
class Doller
{
  float xPos, yPos, spinValue;
  int d;
  boolean collected, extreme;
  Doller(float x, float y)
  {
    xPos = x;    //Horizontal Position
    yPos = y;    //Vertical Position
    d = 3;
    spinValue = 1;
    extreme = true;
  }
  public void Render()
  {
    if (collected == false)
    {

      fill(150);
      ellipse(xPos*d, yPos*d, spinValue*16*d, 16*d);
      fill(90);
      ellipse((xPos)*d, (yPos)*d, spinValue*14*d, 14*d);
      fill(150);
      ellipse((xPos)*d, (yPos)*d, spinValue*12*d, 12*d);

      if (spinValue >=0.25f && extreme == true)
      {
        spinValue -= 0.05f;
      }
      if (spinValue <=0.25f)
      {
        extreme = false;
      }
      if (spinValue <=1 && extreme == false)
      {
        spinValue += 0.05f;
      }
      if (spinValue >=1)
      {
        extreme = true;
      }
      if (((t.p1.xPos+8 > xPos-8) && (t.p1.xPos-8 < xPos+8)) && ((t.p1.yPos+8 > yPos-8) && (t.p1.yPos-8 < yPos+8)))
      {
        coin.play();
        t.dollers ++;
        t.score += 10;
        collected = true;
      }
    }
  }
}
class DollerAll
{
  Doller[] dollers;
  Doller d1, d2, d3, d4;
  int level;
  DollerAll(int l)
  {
    level = l;
    //define dollers ahead of time for control
    d1 = new Doller(64, 384); //1-1 dollers

    d2 = new Doller(80, 384);

    d3 = new Doller(96, 384);

    d4 = new Doller(112, 384);
  }
  public void LevelInit()
  { //arrayify doller for convenience
    dollers = new Doller[1];
    for (int i = 0; i < dollers.length; i++)
    {
      dollers[i] = new Doller(-128, -128);
    }
    if (level == 1)
    {
      dollers = (Doller[])  append(dollers, d1);
      dollers = (Doller[])  append(dollers, d2);
      dollers = (Doller[])  append(dollers, d3);
      dollers = (Doller[])  append(dollers, d4);
    }
    if (level == 2)
    {
    }
    if (level == 3)
    {
    }
  }
  public void Render()
  {
    for (int i = 0; i < dollers.length; i++)
    {
      dollers[i].Render();
    }
  }
}
//Hitbox hitbox;
class Rat
{
  Hitbox hitbox;
  boolean safe, sound;
  float xPos, yPos, lTarget, rTarget, PawHeightA, PawHeightB, speed, yVelocity;
  int stepTimer, d, rotate;
  int dir; //0 and 1 = left and right, respectively. Bool'ing it broke, oh well
  Rat(float x, float y, int f, float l, float r, float s)
  {

    xPos = x;
    yPos = y;
    dir = f;
    speed = s;
    lTarget = l;
    rTarget = r;
    stepTimer=30;
    PawHeightA=0;
    PawHeightB=1.5f;
    hitbox = new Hitbox((xPos/d)-2, (yPos/d)-16, 28, 16);
    yVelocity = -5;
    safe = true;
  }
  public void Render()
  {

    hitbox.xPos = (xPos/d)-2;
    hitbox.yPos = (yPos/d)-16;
    hitbox.safe = safe;

    if (speed > 1.5f) //sanity check; dont fast the rat
    {
      speed = 1.5f;
    }
    if (speed < 0.5f) //sanity check; dont make immobile rats
    {
      speed = 0.5f;
    }

    stepTimer--;
    if (stepTimer>=15)
    {
      PawHeightA+=0.1f;
      PawHeightB-=0.1f;
    }
    if (stepTimer<15)
    {
      PawHeightA-=0.1f;
      PawHeightB+=0.1f;
    }
    if (stepTimer==0)
    {
      stepTimer=30;
    }
    d = 3;
    if (dir==0)//0 = left
    { //DRAW A RAT facing left if it's facing left.
      fill(0xFF000000); //from-camera paws
      arc(xPos+(4*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(17*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      fill(0xFFE0743E);
      triangle(xPos+(22*d), yPos-(6*d), xPos+(18*d), yPos-(6*d), xPos+(24*d), yPos-(16*d));//tail
      fill(0xFF143D52);
      ellipse(xPos+(2*d), yPos-(12*d), 7*d, 8*d);// back ear
      fill(0xFF3F9FCF);
      ellipse(xPos+(11*d), yPos-(6*d), 22*d, 11*d);//body
      ellipse(xPos+(2*d), yPos-(8*d), 11*d, 9*d);//head A
      fill(0xFF00E600);
      ellipse(xPos, yPos-28, 1*d, 2*d);//eyes
      ellipse(xPos-(2*d), yPos-28, 1*d, 2*d);
      fill(0xFF3F9FCF);
      ellipse(xPos-(2*d), yPos-(6*d), 16*d, 5*d);//head B
      ellipse(xPos+(4*d), yPos-(12*d), 7*d, 8*d);//front ear A
      fill(0xFFE0743E);
      ellipse(xPos+(4*d), yPos-(12*d), 5*d, 6*d);//front ear B
      circle(xPos-(9*d), yPos-(7*d), 2*d);//nose
      fill(0xFF143D52); //towards-camera paws
      arc(xPos+(6*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(19*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      //MOVING THE RAT
      if (xPos > lTarget);
      {//if right of target go left
        xPos -= speed*d;
      }
      if (xPos <= lTarget)
      {//if at or beyond target turn around
        dir = 1;
        xPos += 2*d;
      }
    }
    if (dir==1)//1 = right
    {
      //DRAW A RAT facing right if it's facing right.
      fill(0xFF000000); //from-camera paws
      arc(xPos+(20*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(7*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      fill(0xFFE0743E);
      triangle(xPos+(2*d), yPos-(6*d), xPos+(6*d), yPos-(6*d), xPos+(0*d), yPos-(16*d));//tail
      fill(0xFF143D52);
      ellipse(xPos+(22*d), yPos-(12*d), 7*d, 8*d);// back ear
      fill(0xFF3F9FCF);
      ellipse(xPos+(13*d), yPos-(6*d), 22*d, 11*d);//body
      ellipse(xPos+(22*d), yPos-(8*d), 11*d, 9*d);//head A
      fill(0xFF00E600);
      ellipse(xPos+(24*d), yPos-28, 1*d, 2*d);//eyes
      ellipse(xPos+(26*d), yPos-28, 1*d, 2*d);
      fill(0xFF3F9FCF);
      ellipse(xPos+(26*d), yPos-(6*d), 16*d, 5*d);//head B
      ellipse(xPos+(20*d), yPos-(12*d), 7*d, 8*d);//front ear A
      fill(0xFFE0743E);
      ellipse(xPos+(20*d), yPos-(12*d), 5*d, 6*d);//front ear B
      circle(xPos+(33*d), yPos-(7*d), 2*d);//nose
      fill(0xFF143D52); //towards-camera paws
      arc(xPos+(18*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(5*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      //MOVING THE RAT
      {
        if (xPos < rTarget);
        {//if left of target go right
          xPos += speed*d;
        }
        if (xPos >= rTarget)
        {//if at or beyond target turn around
          dir = 0;
          xPos -= speed*d;
        }
      }
    }
    if (hitbox.dead == false)
    {
      hitbox.Collide();
    }
    if (hitbox.dead == true || t.levelClear == true)
    {
      if (sound == false)
      {
        bonk.play();
        sound = true;
      }
      yVelocity += 0.3f;
      yPos = yPos + yVelocity;
    }

  }
}
//Hitbox hitbox;
class MadRat
{
  Hitbox hitbox;
  boolean safe, sound;
  float xPos, yPos, lTarget, rTarget, PawHeightA, PawHeightB, speed, yVelocity;
  int stepTimer, d, rotate;
  int dir; //0 and 1 = left and right, respectively. Bool'ing it broke, oh well
  MadRat(float x, float y, int f, float l, float r, float s)
  {

    xPos = x;
    yPos = y;
    dir = f;
    speed = s;
    lTarget = l;
    rTarget = r;
    stepTimer=30;
    PawHeightA=0;
    PawHeightB=1.5f;
    hitbox = new Hitbox((xPos/d)-2, (yPos/d)-16, 28, 16);
    yVelocity = -5;
    safe = false;
  }
  public void Render()
  {

    hitbox.xPos = (xPos/d)-2;
    hitbox.yPos = (yPos/d)-16;
    hitbox.safe = safe;

    if (speed > 1.5f) //sanity check; dont fast the rat
    {
      speed = 1.5f;
    }
    if (speed < 0.5f) //sanity check; dont make immobile rats
    {
      speed = 0.5f;
    }

    stepTimer--;
    if (stepTimer>=15)
    {
      PawHeightA+=0.1f;
      PawHeightB-=0.1f;
    }
    if (stepTimer<15)
    {
      PawHeightA-=0.1f;
      PawHeightB+=0.1f;
    }
    if (stepTimer==0)
    {
      stepTimer=30;
    }
    d = 3;
    if (dir==0)//0 = left
    { //DRAW A RAT facing left if it's facing left.
      fill(0xFF000000); //from-camera paws
      arc(xPos+(4*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(17*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      fill(0xFFE0743E);
      triangle(xPos+(22*d), yPos-(6*d), xPos+(18*d), yPos-(6*d), xPos+(24*d), yPos-(16*d));//tail
      fill(0xFF143D52);
      ellipse(xPos+(2*d), yPos-(12*d), 7*d, 8*d);// back ear
      fill(0xFF257298);
      ellipse(xPos+(11*d), yPos-(6*d), 22*d, 11*d);//body
      ellipse(xPos+(2*d), yPos-(8*d), 11*d, 9*d);//head A
      fill(0xFFE6E600);
      ellipse(xPos, yPos-28, 1*d, 2*d);//eyes
      ellipse(xPos-(2*d), yPos-28, 1*d, 2*d);
      fill(0xFF257298);
      ellipse(xPos-(2*d), yPos-(6*d), 16*d, 5*d);//head B
      ellipse(xPos+(4*d), yPos-(12*d), 7*d, 8*d);//front ear A
      fill(0xFFE0743E);
      ellipse(xPos+(4*d), yPos-(12*d), 5*d, 6*d);//front ear B
      circle(xPos-(9*d), yPos-(7*d), 2*d);//nose
      fill(0xFF143D52); //towards-camera paws
      arc(xPos+(6*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(19*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      //MOVING THE RAT
      if (xPos > lTarget);
      {//if right of target go left
        xPos -= speed*d;
      }
      if (xPos <= lTarget)
      {//if at or beyond target turn around
        dir = 1;
        xPos += 2*d;
      }
    }
    if (dir==1)//1 = right
    {
      //DRAW A RAT facing right if it's facing right.
      fill(0xFF000000); //from-camera paws
      arc(xPos+(20*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(7*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      fill(0xFFE0743E);
      triangle(xPos+(2*d), yPos-(6*d), xPos+(6*d), yPos-(6*d), xPos+(0*d), yPos-(16*d));//tail
      fill(0xFF143D52);
      ellipse(xPos+(22*d), yPos-(12*d), 7*d, 8*d);// back ear
      fill(0xFF257298);
      ellipse(xPos+(13*d), yPos-(6*d), 22*d, 11*d);//body
      ellipse(xPos+(22*d), yPos-(8*d), 11*d, 9*d);//head A
      fill(0xFFE6E600);
      ellipse(xPos+(24*d), yPos-28, 1*d, 2*d);//eyes
      ellipse(xPos+(26*d), yPos-28, 1*d, 2*d);
      fill(0xFF257298);
      ellipse(xPos+(26*d), yPos-(6*d), 16*d, 5*d);//head B
      ellipse(xPos+(20*d), yPos-(12*d), 7*d, 8*d);//front ear A
      fill(0xFFE0743E);
      ellipse(xPos+(20*d), yPos-(12*d), 5*d, 6*d);//front ear B
      circle(xPos+(33*d), yPos-(7*d), 2*d);//nose
      fill(0xFF143D52); //towards-camera paws
      arc(xPos+(18*d), yPos-(PawHeightB*d)+1, (8*d), (6*d), PI, TWO_PI);
      arc(xPos+(5*d), yPos-(PawHeightA*d)+1, (8*d), (6*d), PI, TWO_PI);
      //MOVING THE RAT
      {
        if (xPos < rTarget);
        {//if left of target go right
          xPos += speed*d;
        }
        if (xPos >= rTarget)
        {//if at or beyond target turn around
          dir = 0;
          xPos -= speed*d;
        }
      }
    }
    if (hitbox.dead == false)
    {
      hitbox.Collide();
    }
    if (hitbox.dead == true|| t.levelClear == true)
    {
      if (sound == false)
      {
        bonk.play();
        sound = true;
      }
      yVelocity += 0.3f;
      yPos = yPos + yVelocity;
    }
  }
}
class Gaffy
{//its me!
  float xPos, yPos, grabX, grabY, xSpeed, ySpeed, gravity, yVelocity, jumpModifier, jumpFlag, tailAngle, hammerHitX, hammerHitY;
  int d, animTimer, dir, grabbingID, hammerTime, score, dollers, leveltimer, health, iframe, hitDir;
  boolean keyw, keya, keys, keyd, keyj, keyk, keyl, isGrabbing, hammerUse, gameover, jumpframes;

  //for whatever reason including these variables here makes things nicer
  boolean gm; //gamemode handler; false is menu, true is level
  int level;  //level tracker

  Gaffy(float x, float y, int f, float j, int hp)
  {
    d = 3;
    xPos = x + 8;    //Horizontal Position
    yPos = y + 12;   //Vertical Position
    dir = f;         //facing
    jumpFlag = j;    //is gaffy jumping?
    jumpModifier = 0;//modify graphic for jumps
    gm = false;
    health = hp;
  }


  public void Render()
  {

    tailAngle=30;
    d = 3;
    gravity = 0.15f; // hacky physics in this object! featuring a hacky collision engine! im proud of this!
    //test square; not gonna be gaffy's real shape lol
    //fill(255);
    //rect((xPos)*d, (yPos)*d, (32*d), (32*d));
    //DRAW GAFFY...
    if (iframe % 4 == 0 || iframe % 4 == 1)
    {
      if (dir == 0)
      {//.. facing left
        //tail
        translate((xPos+10)*d, (yPos+8)*d);
        rotate(radians(-tailAngle));
        fill(0xFF1765BB);
        ellipse(0*d, 0*d, 15*d, 10*d);
        fill(0xFF0C3460);
        arc(0, (0)*d, 15*d, 10*d, PI+HALF_PI, TWO_PI+HALF_PI, CHORD);
        fill(255);
        triangle((3)*d, (-5)*d, (3)*d, (5)*d, (13)*d, (0)*d);
        rotate(radians(tailAngle));
        translate((-(xPos+10)*d), (-(yPos+8)*d));
        fill(0xFF1765BB);  //back arm
        circle((xPos-3-(2*jumpModifier))*d, (yPos+8.5f-(12*jumpModifier))*d, 5*d);
        fill(0xFF0C3460);
        ellipse((xPos-5-(2*jumpModifier))*d, (yPos+9.5f-(16*jumpModifier))*d, 6*d, 4*d);
        fill(0xFF1765BB);  //torso
        ellipse(xPos*d, (yPos+8)*d, (13*d), (11*d));
        //paws
        fill(0xFF1765BB);
        ellipse((xPos-1.5f-(1*jumpModifier))*d, (yPos+16-(3*jumpModifier))*d, 4*d, 8*d);
        fill(0xFF0C3460);
        arc((xPos-2-(1*jumpModifier))*d, (yPos+20-(3*jumpModifier))*d, (8*d), (6*d), PI, TWO_PI);
        fill(0xFF1765BB);
        ellipse(((xPos+2.5f))*d, (yPos+16+(0.5f*jumpModifier))*d, 4*d, 8*d);
        fill(0xFF0C3460);
        arc(((xPos+2))*d, ((yPos+20+(0.5f*jumpModifier))*d), (8*d), (6*d), PI, TWO_PI);
        fill(0);        //shirt
        arc(xPos*d, (yPos+8)*d, (13*d), (11*d), PI-0.85f, TWO_PI+0.85f, CHORD);
        fill(0xFF1765BB);  //front arm
        circle((xPos+1+(1*jumpModifier))*d, (yPos+8.5f+jumpModifier)*d, 5*d);
        fill(0xFF0C3460);
        ellipse((xPos-1+(4*jumpModifier))*d, (yPos+9.5f+jumpModifier)*d, 6*d, 4*d);
        fill(0xFF0C3460);  //back ear
        triangle((xPos+1)*d, (yPos-7)*d, (xPos-6)*d, (yPos-4)*d, (xPos-3)*d, (yPos-14)*d);
        fill(0xFF1765BB);  //head base
        ellipse(xPos*d, (yPos-1)*d, (13*d), (12*d));
        triangle((xPos+1)*d, (yPos-7)*d, (xPos-6)*d, (yPos-3)*d, (xPos-8)*d, (yPos-8)*d);
        fill(255);
        fill(0xFFEC1DED);
        ellipse((xPos-2)*d, (yPos-2)*d, 1*d, 2*d);
        ellipse((xPos-4)*d, (yPos-2)*d, 1*d, 2*d);
        fill(255);      //muzzle
        ellipse((xPos-2)*d, (yPos+2)*d, (18*d), (6*d));
        fill(0);        //nose
        circle((xPos-10)*d, (yPos+1)*d, (3*d));
        fill(0xFF0C3460);  //front ear
        triangle((xPos-1)*d, (yPos-7)*d, (xPos+6)*d, (yPos-4)*d, (xPos+3)*d, (yPos-14)*d);
        fill(255);      //ear fill
        triangle((xPos)*d, (yPos-8)*d, (xPos+4.5f)*d, (yPos-5.5f)*d, (xPos+3)*d, (yPos-13)*d);
        grabX = xPos-24;
        grabY = yPos;
      }


      if (dir == 1)
      {//...facing right
        //tail
        translate((xPos-10)*d, (yPos+8)*d);
        rotate(radians(240-tailAngle));
        fill(0xFF1765BB);
        ellipse(0*d, 0*d, 15*d, 10*d);
        fill(0xFF0C3460);
        arc(0, (0)*d, 15*d, 10*d, PI+HALF_PI, TWO_PI+HALF_PI, CHORD);
        fill(255);
        triangle((3)*d, (-5)*d, (3)*d, (5)*d, (13)*d, (0)*d);
        rotate(radians(-(240-tailAngle)));
        translate((-(xPos-10)*d), (-(yPos+8)*d));
        fill(0xFF1765BB);  //back arm
        circle((xPos+3+(2*jumpModifier))*d, (yPos+8.5f-(12*jumpModifier))*d, 5*d);
        fill(0xFF0C3460);
        ellipse((xPos+5+(2*jumpModifier))*d, (yPos+9.5f-(16*jumpModifier))*d, 6*d, 4*d);
        fill(0xFF1765BB);  //torso
        ellipse(xPos*d, (yPos+8)*d, (13*d), (11*d));
        //paws
        fill(0xFF1765BB);
        ellipse((xPos+1.5f+(1*jumpModifier))*d, (yPos+16-(3*jumpModifier))*d, 4*d, 8*d);
        fill(0xFF0C3460);
        arc((xPos+2+(1*jumpModifier))*d, (yPos+20-(3*jumpModifier))*d, (8*d), (6*d), PI, TWO_PI);
        fill(0xFF1765BB);
        ellipse((xPos-2.5f)*d, (yPos+16+(0.5f*jumpModifier))*d, 4*d, 8*d);
        fill(0xFF0C3460);
        arc((xPos-2)*d, (yPos+20+(0.5f*jumpModifier))*d, (8*d), (6*d), PI, TWO_PI);
        fill(0);        //shirt
        arc(xPos*d, (yPos+8)*d, (13*d), (11*d), PI-0.85f, TWO_PI+0.85f, CHORD);
        fill(0xFF1765BB);  //front arm
        circle((xPos-1-(1*jumpModifier))*d, (yPos+8.5f+jumpModifier)*d, 5*d);
        fill(0xFF0C3460);
        ellipse((xPos+1-(4*jumpModifier))*d, (yPos+9.5f+jumpModifier)*d, 6*d, 4*d);
        fill(0xFF0C3460);  //back ear
        triangle((xPos-1)*d, (yPos-7)*d, (xPos+6)*d, (yPos-4)*d, (xPos+3)*d, (yPos-14)*d);
        fill(0xFF1765BB);  //head base
        ellipse(xPos*d, (yPos-1)*d, (13*d), (12*d));
        triangle((xPos-1)*d, (yPos-7)*d, (xPos+6)*d, (yPos-3)*d, (xPos+8)*d, (yPos-8)*d);
        fill(255);
        fill(0xFFEC1DED);
        ellipse((xPos+2)*d, (yPos-2)*d, 1*d, 2*d);
        ellipse((xPos+4)*d, (yPos-2)*d, 1*d, 2*d);
        fill(255);      //muzzle
        ellipse((xPos+2)*d, (yPos+2)*d, (18*d), (6*d));
        fill(0);        //nose
        circle((xPos+10)*d, (yPos+1)*d, (3*d));
        fill(0xFF0C3460);  //front ear
        triangle((xPos+1)*d, (yPos-7)*d, (xPos-6)*d, (yPos-4)*d, (xPos-3)*d, (yPos-14)*d);
        fill(255);      //ear fill
        triangle((xPos)*d, (yPos-8)*d, (xPos-4.5f)*d, (yPos-5.5f)*d, (xPos-3)*d, (yPos-13)*d);
        grabX = xPos+8;
        grabY = yPos;
      }
    }
  }
  public void gaffyLogic()
  {
    if (jumpframes == true)
    {
      jump.play();
      jumpframes = false;
    }
    if (iframe >0)
    {
      iframe--;
    }
    if (iframe ==59)
    {
      hurt.play();
    }
    t.p1.hammerUse = hammerUse;
    if (hammerUse == true)
    {

      hammerUse = false;
      hammerTime =30;
    }
    if (hammerTime == 30)
    {
      slam.play();
    }
    if (hammerTime < -30) //hammer attack
    {
      hammerTime = -30;
    }
    if (hammerTime > 0)
    {
      if (dir == 0)
      {
        fill(0xFF9B6B16);
        rect((xPos-32)*d, (yPos+8)*d, 24*d, 4*d);
        fill(32);
        rect((xPos-30)*d, (yPos+2)*d, 10*d, 16*d);
        hammerHitX = xPos-32;
        hammerHitY = yPos+2;
      }
      if (dir == 1)
      {
        fill(0xFF9B6B16);
        rect((xPos+8)*d, (yPos+8)*d, 24*d, 4*d);
        fill(32);
        rect((xPos+20)*d, (yPos+2)*d, 10*d, 16*d);
        hammerHitX = xPos+8;
        hammerHitY = yPos+2;
      }
    }
    hammerTime --;
    hammerTime = t.p1.hammerTime;
    if ((yPos  >= 528 || t.leveltimer < 0 || t.hp <= 0) && t.lives >0) //respawn
    {
      respawn.play();
      xPos = 64;
      yPos = 384;
      t.hp = 3;
      t.lives = t.lives-1;
      t.leveltimer = 23999;
    }
    if ((yPos  >= 528 || t.leveltimer < 0 || t.hp <= 0) && t.lives <=0) //game over
    {
      lv1.stop();
      lv2.stop();
      lv3.stop();
      if (gameover == false)
      {
        gameend.play();
      }
      gameover = true;
      yPos = 1024;
    }
    //JUMPING LOGIC
    //jumpFlag -=1;
    yPos = (yPos + (yVelocity));     //bad physics sim
    yVelocity = yVelocity + gravity;
    if (yVelocity >=10)
    {
      yVelocity = 10;
    }

    if (jumpFlag == 1)
    {
      jumpModifier = 0;
    }
    if (jumpFlag == 0)
    {

      jumpModifier=1;
      yPos = (yPos - 7 + (yVelocity));
    }

    if ((t.gamemode == true && gameover == false) && t.levelClear == false)
    {
      if (keyj == true)
      {
        if (jumpFlag ==1)
        {
          jumpframes = true;
        }
        jumpFlag = 0;
      }
      if (keyj == false)
      {
      }
      if (keya == true)
      {
        dir = 0;
        xPos -=1.5f;
      }
      if (keya == false)
      {
        xPos +=0;
      }
      if (keyd == true)
      {
        dir = 1;
        xPos +=1.5f;
      }
      if (keyd == false)
      {

        xPos +=0;
      }
      if (keyk == true) //complicated grab logic
      {
        isGrabbing = true;
      }
      if (keyk == false)
      {
        isGrabbing = false;
        grabbingID = 0;
      }
      if (keyl == true) //attack; likely debug placement for now
      {
        if (hammerTime <= -15)
        {
          hammerUse = true;
        }
      }
      if (keyl == false)
      {
      }
      if (xPos < 12)
      {
        xPos = 12;
      }
      if (xPos > 1012)
      {
        xPos = 1012;
      }
    }
    if (hitDir == 1 && iframe >0)
    {
      xSpeed = -0.5f;
    }
    if (hitDir == 1 && iframe >0)
    {
      xSpeed = 0.5f;
    }
  }
  public void keyStart(char k)
  {
    if (keyPressed == true)
    {
      if (k == 'a')
      {
        keya = true;
      }
      if (k == 'd')
      {
        keyd = true;
      }
      if (k == 'w')
      {
        keyw = true;
      }
      if (k == 's')
      {
        keys = true;
      }
      if (k == 'j')
      {
        keyj = true;
      }
      if (k == 'k')
      {
        keyk = true;
      }
      if (k == 'l')
      {
        keyl = true;
      }
    }
  }
  public void keyStop(char k)
  {
    if (keya == true && k == 'a')
    {
      keya = false;
    }
    if (keyd == true && k == 'd')
    {
      keyd = false;
    }
    if (keyw == true && k == 'w')
    {
      keyw = false;
    }
    if (keys == true && k == 's')
    {
      keys = false;
    }
    if (keyj == true && k == 'j')
    {
      keyj = false;
    }
    if (keyk == true && k == 'k')
    {
      keyk = false;
    }
    if (keyl == true && k == 'l')
    {
      keyl = false;
    }
  }
}
class Ground
{
  GroundDetail[] detail;
  CollisionSolids collide;
  CollideBoulder collideB;
  float xPos, yPos;
  int d, xScale, yScale, id, tileX, tileY, tileTotal;
  Ground(float x, float y, int xs, int ys)
  {
    xPos = x;
    yPos = y;
    xScale = xs;
    yScale = ys;
    tileX = xScale/16;
    tileY = yScale/16;
    tileTotal = (tileX*tileY);
  }

  public void Render()
  {
    detail = new GroundDetail[tileTotal];
    int id = 0;
    for (int yTile = 0; yTile < tileY; yTile++)
    {
      for (int xTile = 0; xTile < tileX; xTile++)
      {
        detail[id] = new GroundDetail(xPos, yPos, xTile, yTile);
        id++;
      }
    }

    collide = new CollisionSolids(xPos, yPos, xScale, yScale);
    collideB = new CollideBoulder(xPos, yPos, xScale, yScale); //hook collision into it
    d=3;
    if (yScale < 16)
    {
      yScale = 16;
    }
    if (xScale < 16)
    {
      xScale = 16;
    }
    collide.Collide();
    collideB.Collide();
    noStroke(); //draw the ground
    fill(0xFF8C633C);
    rect(xPos*d, yPos*d, xScale*d, yScale*d);
    fill(0xFF00B800);
    rect(xPos*d, yPos*d, xScale*d, 4*d);
    for (int i = 0; i < detail.length; i++)
    {
      detail[i].Render();
    }
  }
}
class GroundAll
{
  Ground[] grounds;
  Ground g1, g2, g3, g4, g5;
  int level;
  GroundAll(int l)
  {
    level = l;
    //define grounds ahead of time for control
    g1 = new Ground(64, 448, 128, 64); //1-1 grounds

    g2 = new Ground(192, 384, 128, 128);

    g3 = new Ground(-48, 416, 128, 192);

    g4 = new Ground(384, 384, 896, 32);
    g5 = new Ground(320, 400, 64, 32);
  }
  public void LevelInit()
  { //arrayify ground for collision
    grounds = new Ground[1];
    for (int i = 0; i < grounds.length; i++)
    {
      grounds[i] = new Ground(-128, -128, 16, 16);
    }
    if (level == 1)
    {
      grounds = (Ground[])  append(grounds, g1);
      grounds = (Ground[])  append(grounds, g2);
      grounds = (Ground[])  append(grounds, g3);
      grounds = (Ground[])  append(grounds, g4);
      //grounds = (Ground[])  append(grounds, g5);
    }
    if (level == 2)
    {
    }
    if (level == 3)
    {
    }
  }
  public void Render()
  {
    for (int i = 0; i < grounds.length; i++)
    {
      grounds[i].Render();
    }
  }
}
class GroundDetail
{
  float xPos, yPos;
  int xTile, yTile, id, d;

  GroundDetail(float x, float y, int w, int h)
  {
    xPos = x;
    yPos = y;
    xTile = w;
    yTile = h;
  }


  public void Render()
  {
    d=3;
    noStroke(); //draw the ground details
    fill(0xFFC19571);
    quad((xPos+(xTile*16))*d, (yPos+6+(yTile*16))*d, (xPos+8+(xTile*16))*d, (yPos+10+(yTile*16))*d, (xPos+8+(xTile*16))*d, (yPos+14+(yTile*16))*d, (xPos+(xTile*16))*d, (yPos+10+(yTile*16))*d);
    quad((xPos+16+(xTile*16))*d, (yPos+6+(yTile*16))*d, (xPos+8+(xTile*16))*d, (yPos+10+(yTile*16))*d, (xPos+8+(xTile*16))*d, (yPos+14+(yTile*16))*d, (xPos+16+(xTile*16))*d, (yPos+10+(yTile*16))*d);
  }
}
class HUD
{
  int d, levelID, displaytimer;
  float xPos, yPos;
  PFont Menu;
  HUD()
  {
    Menu = createFont("menu.ttf", 24);
  }

  public void Render()
  {
    {
      d = 3; //everything is *3 in this image to emulate snes 256x224 resolution.
      fill(0xFF9B6B16); //HUD, work in progress
      rect(0*d, 0*d, 256*d, 48*d);
      fill(0xFFE1AE3F);
      rect(1*d, 1*d, 254*d, 46*d);
      fill(240);
      rect(4*d, 4*d, 248*d, 40*d);

      //icons
      fill (150);     //controller, used for score
      rect(21*d, 8*d, 18*d, 12*d);
      ellipse(20*d, 16*d, 14*d, 16*d);
      ellipse(40*d, 16*d, 14*d, 16*d);
      circle(20*d, 32*d, 16*d); //dollers (intentional spelling) count
      fill(90);
      circle(20*d, 32*d, 14*d);
      fill(150);
      circle(20*d, 32*d, 12*d);
      fill(0xFFE1AE3F);  // level minimap bg
      rect(144*d, 8*d, 96*d, 32*d);
      circle(87*d, 32*d, 16*d); //timer
      fill(255);
      circle(87*d, 32*d, 14*d);
      fill(0xFF1765BB);   //health meter
      if (t.hp >=1)
      {
        ellipse(112*d, 16*d, 7*d, 15*d);
      }
      if (t.hp >=2)
      {
        ellipse(120*d, 16*d, 7*d, 15*d);
      }
      if (t.hp ==3)
      {
        ellipse(128*d, 16*d, 7*d, 15*d);
      }
      xPos = 160;     //vestigial variables from Gaffy render script, didn't feel like rewriting them entirely
      yPos = 32;      //used for life counter
      fill(0xFF0C3460);  //back ear
      triangle((xPos-1)*d, (yPos-7)*d, (xPos+6)*d, (yPos-4)*d, (xPos+3)*d, (yPos-14)*d);
      fill(0xFF1765BB);  //head base
      ellipse(xPos*d, (yPos-1)*d, (13*d), (12*d));
      triangle((xPos-1)*d, (yPos-7)*d, (xPos+6)*d, (yPos-3)*d, (xPos+8)*d, (yPos-8)*d);
      fill(255);
      fill(0xFFEC1DED);
      ellipse((xPos+2)*d, (yPos-2)*d, 1*d, 2*d);
      ellipse((xPos+4)*d, (yPos-2)*d, 1*d, 2*d);
      fill(255);      //muzzle
      ellipse((xPos+2)*d, (yPos+2)*d, (18*d), (6*d));
      fill(0);        //nose
      circle((xPos+10)*d, (yPos+1)*d, (3*d));
      fill(0xFF0C3460);  //front ear
      triangle((xPos+1)*d, (yPos-7)*d, (xPos-6)*d, (yPos-4)*d, (xPos-3)*d, (yPos-14)*d);
      fill(255);      //ear fill
      triangle((xPos)*d, (yPos-8)*d, (xPos-4.5f)*d, (yPos-5.5f)*d, (xPos-3)*d, (yPos-13)*d);
      displaytimer = t.leveltimer/60;
      //text
      textAlign(LEFT, TOP);
      fill(255);
      textFont(Menu);
      text("LVL 1-" + levelID, 176*d, 16*d);
      text("x"+t.lives, 176*d, 28*d);
      fill(0);
      if (t.dollers < 10)
      {
        text("D0"+t.dollers, 32*d, 32*d);
      }
      if (t.dollers >= 10)
      {
        text("D"+t.dollers, 32*d, 32*d);
      }
      text(displaytimer, 96*d, 32*d);
      textAlign(RIGHT, TOP);
      text(t.score + "pt", 104*d, 16*d);

      if (t.p1.gameover == true)
      {
        rectMode(CENTER);
        fill(0xFFE1AE3F);  // level minimap bg
        rect(128*d, 128*d, 96*d, 24*d);
        rectMode(CORNER);
        fill(255);
        textAlign(CENTER, CENTER);
        text("GAME OVER!", 128*d, 128*d);
      }
    }
  }
}
class Level1
{
  GroundAll ground;
  DollerAll doller;
  BoxAll boxes;
  Rat rat1, rat2;
  MadRat mad1;
  BusStop bus;
  int d, timestart;
  boolean levelInit, clear;

  Level1()
  {
    d = 3;
 
    ground = new GroundAll(1);
    ground.LevelInit();
    doller = new DollerAll(1);
    doller.LevelInit();
    boxes = new BoxAll(1);
    boxes.LevelInit();
    rat1 = new Rat(224*d, 384*d, 0, 192*d, 288*d, 0.8f);
    rat2 = new Rat(64*d, 416*d, 0, -64*d, 48*d, 1.2f);
    mad1 = new MadRat(512*d, 384*d, 0, 512*d, 640*d, 0.8f);
    bus = new BusStop(768, 304)
      ;
  }
  public void Render()
  {
    if (lv1.isPlaying() == false && t.levelClear == false)
    {
      lv1.play();
    }
    if (levelInit == false)
    {
      t.p1.xPos = 48;
      t.p1.yPos = 416;
      levelInit = true;
    }

    bus.Render();
    ground.Render();
    doller.Render();
    rat1.Render();
    //rat2.Render();
    mad1.Render();
    boxes.Render();
  }
}
class Level2
{
  GroundAll ground;
  DollerAll doller;

  BoxAll boxes;
  int d;
    boolean levelInit, clear;
  Level2()
  {
        clear = false;
    ground = new GroundAll(1);
    ground.LevelInit();
    doller = new DollerAll(1);
    doller.LevelInit();
    boxes = new BoxAll(1);
    boxes.LevelInit();
  }
  public void Render()
  {
    if (lv2.isPlaying() == false&& t.levelClear == false)
    {
      lv2.play();
    }
  }
}
class Level3
{
  GroundAll ground;
  DollerAll doller;

  BoxAll boxes;
  int d;
  boolean levelInit, clear;
  Level3()
  {
    clear = false;
    ground = new GroundAll(1);
    ground.LevelInit();
    doller = new DollerAll(1);
    doller.LevelInit();
    boxes = new BoxAll(1);
    boxes.LevelInit();
  }
  public void Render()
  {
    if (lv3.isPlaying() == false&& t.levelClear == false)
    {
      lv3.play();
    }
  }
}
class Menu
{
  Ground g1;
  MenuPointer m1;
  int d;
  int menuSelect, buttonPressed, levelID;
  boolean selection, back;
  boolean isDebug, isCredits;
  boolean keyw, keya, keys, keyd, keyj, keyk, keyl;
  PFont Menu;
  PFont Title;
  Menu()
  {
    d=3;
    Menu = createFont("menu.ttf", 24);
    Title = createFont("title.otf", 128);
    m1 = new MenuPointer(0);
    g1 = new Ground(0, 192, 256, 32);
  }
  public void Render()
  {
    if (title.isPlaying() == false)
    {
      title.play();
    }
    g1.Render();

    m1.Render();
    //menu text
    fill(255);
    textAlign(LEFT, TOP);
    textFont(Menu);
    if (isCredits == false)
    {
      text("PRESS J TO SELECT", 64*d, 112*d);
      if (isDebug == false)
      {
        text("START GAME", 80*d, 128*d);
      }
      if (isDebug == true)
      {
        text("DEBUG 1-1", 80*d, 128*d);
        text("DEBUG 1-2", 80*d, 144*d);
        text("DEBUG 1-3", 80*d, 160*d);
      }
      text("CREDITS", 80*d, 176*d);
    }
    if (isCredits == true)
    {
      fill(0xFF1765BB);
      rect(24*d, 24*d, 212*d, 188*d, 50);
      fill(255);
      textAlign(LEFT, TOP);
      if (isDebug == true);
      {
        text("GAFFYGAME v" + t.vernum, 32*d, 32*d);
      }
      if (isDebug == false);
      {
        text("GAFFYGAME ALPHA VERSION", 32*d, 32*d);
      }
      text("GAME CODE WRITTEN", 32*d, 48*d);
      text("BY COLBY 'GAFFY' HOCKING", 32*d, 64*d);
      text("FONTS ARE PENGO ARCADE", 32*d, 80*d);
      text("AND ASTRON BOY", 32*d, 96*d);
      text("TEMP AUDIO C. NINTENDO", 32*d, 112*d);
      text("SPECIAL THANKS TO OZ", 32*d, 128*d);

      text("FOR HELP GETTING TO", 32*d, 144*d);

      text("1.x.x.x BUILD", 32*d, 160*d);
      text("PRESS K TO RETURN", 32*d, 192*d);
    }
    //Title
    if (isCredits == false)
    {
      textAlign(CENTER, TOP);
      fill(0xFF0C3460);
      rect(32*d, 24*d, 192*d, 80*d, 50);
      fill(255);
      fill(0xFF1765BB);
      textFont(Title);
      text("GAFFY", 124*d, 32*d);
      text("THE FOX", 124*d, 64*d);

      textFont(Menu);
      fill(255);
      text("C 2024-202x GAFFY", 128*d, 216*d);
    }
  }
  public void keyHandler()
  {
    buttonPressed --; //menu controls: w and s go up and down, j selects, k backs out of credits
    if (buttonPressed < 0)
    {
      buttonPressed = 0;
    }

    if (buttonPressed == 0)
    {
      if (keyw == true)
      {
        m1.choice -=1;
        buttonPressed = 10;
      }
      if (keys == true)
      {
        m1.choice +=1;
        buttonPressed = 10;
      }
    }
    if (keyw == false)
    {
    }
    if (keys == false)
    {
    }
    if (keyj == true)
    {
      selection = true;
    }
    if (keyj == false)
    {
      selection = false;
    }
    if (keyk == true)
    {
      back = true;
    }
    if (keyk == false)
    {
      back = false;
    }
    if (m1.choice < 0) //bounds for menu options
    {
      m1.choice = 0;
    }
    if (m1.choice > 3)
    {
      m1.choice = 3;
    }
    if (isDebug == false) //if not debug mode, skip the debug options
    {
      if (m1.choice == 1)
      {
        m1.choice = 3;
      }
      if (m1.choice == 2)
      {
        m1.choice = 0;
      }
    }
  }
  public void choicerCredits()
  {

    if (selection == true && m1.choice == 3)
    {
      isCredits = true;
      m1.credits = true;
    }
    if (back == true && isCredits == true)
    {
      isCredits = false;
      m1.credits = false;
    }
  }
  public void choicerLevel()
  {

    if (selection == true && m1.choice == 0)
    {
      t.levelID = 1;
    }
    if (selection == true && m1.choice == 1)
    {
      t.levelID = 2;

    }
    if (selection == true && m1.choice == 2)
    {
      t.levelID = 3;

    }

  }
  public boolean choicerGM(boolean gamemode)
  {

    if (selection == true && m1.choice < 3)
    {
      return true;
    }

    return false;
  }
  public void keyStart(char k)
  {
    if (keyPressed == true)
    {
      if (k == 'w')
      {
        keyw = true;
      }
      if (k == 's')
      {
        keys = true;
      }
      if (k == 'j')
      {
        keyj = true;
      }
      if (k == 'k')
      {
        keyk = true;
      }
    }
  }
  public void keyStop(char k)
  {
    if (keyw == true && k == 'w')
    {
      keyw = false;
    }
    if (keys == true && k == 's')
    {
      keys = false;
    }
    if (keyj == true && k == 'j')
    {
      keyj = false;
    }
    if (keyk == true && k == 'k')
    {
      keyk = false;
    }
  }
}
class MenuPointer
{
  int choice;
  boolean credits;
  int d;
  MenuPointer(int c)
  {
    choice = c;
    d=3;
  }
  public void Render()
  {
    noStroke(); //draw the ground
    fill(0xFFC19571);
    if (credits == false)
    {
      triangle(64*d, (128*d+(16*d*choice)), 64*d, (136*d+(16*d*choice)), 72*d, (132*d+(16*d*choice)));
    }
  }
}
/* NOT REAL CODE,MOSTLY TO COPY BIG CODE AND HAVE FORMATTING FEATUReS

        for (int i = 1; i < t.l3.boxes.boxes.length; i++)
        {
          if ((((yPos-20 < t.l3.boxes.boxes[i].yPos && (yPos+yScale) > t.l3.boxes.boxes[i].yPos) && ((xPos  - 4 < t.l3.boxes.boxes[i].yPos) && (xPos + 4 + xScale >  t.l3.boxes.boxes[i].yPos)))))
          {
            dead = true;
            t.score += 100;
          }
        }














*/        
class TopLogic
{
  Cloud[] manyClouds;
  HUD hud;
  Menu menu;
  Level1 l1;
  Level2 l2;
  Level3 l3;
  Gaffy p1;
  Boulder boulder;
  String vernum;
  int levelID, d, leveltimer, score, dollers, lives, hp, endTimer, scoreBonus, clearTimer;
  boolean gamemode, levelClear, tallyDone, init;
  float xCam, yCam;
  TopLogic()
  { //define objects in TopLogic's Domain.
    d = 3;
    manyClouds = new Cloud[6];
    for (int i = 0; i<manyClouds.length; i+=1)
    { //array-ified clouds, now with random scrolling and speeds
      manyClouds[i] = new Cloud((96+(8*i)+(random(-16, 16)*16)*d), ((56+((8*i)+(random(0, 8))))*d), (random(-0.8f, 0.8f)));
    }
    hud = new HUD();
    menu = new Menu();

    p1 = new Gaffy(64, 384, 0, 90, 3);
    boulder = new Boulder(448, 384);
    l1 = new Level1();
    l2 = new Level2();
    l3 = new Level3();
    lives = 3;
    hp = 3;
    leveltimer = 23999;
    menu.isDebug=true; //debug flag! set to true for debug mode (a full level select and fps meter)
    endTimer = 300;
  }
  public void GameLoop()
  {
    text(vernum, 1024, 1024);
    println((levelID));
    if (levelClear == true && clearTimer >= 0)
    {
      if (tallyDone == false)
      {
        scoreBonus = (leveltimer / 60) * 10;
        score =  score + scoreBonus;
        scoreBonus = 0;
        lclear.play();
        lv1.stop();
        lv2.stop();
        lv3.stop();
        clearTimer = 180;
        tallyDone = true;
      }
      clearTimer--;
      if (clearTimer <= 0)
      {

        if (levelID == 3)
        {
          exit();
        }
        if (levelID == 2)
        {

          clearTimer = 180;

          levelID = 3;
        }
        if (levelID == 1)
        {


          clearTimer =180;

          levelID = 2;
        }
      }
    }
    if (dollers >= 100)
    {
      oneup.play();
      lives++;
      dollers = 0;
    }
    if (t.p1.gameover == true)
    {
      endTimer --;
    }
    if (endTimer <= 0)
    {
      exit();
      //menu.keyj = false;
      //menu.choicerGM(true) = false;
    }
    if (levelClear == false)
    {
      leveltimer--;
    }
    gamemode = menu.choicerGM(gamemode);
    //Common Rendering: BG
    background(24, 2, 44);
    fill(0xFFFFDE66);
    circle (32*d, 64*d, 48*d);
    fill(24, 2, 44);
    circle(48*d, 64*d, 48*d);
    for (int i = 0; i<manyClouds.length; i+=1)
    {
      manyClouds[i].Render();
    }
    //Camera Logic
    xCam = p1.xPos - 128;
    yCam = p1.yPos - 96;
    if (xCam < 0)
    {
      xCam = 0;
    }
    if (xCam > 768)
    {
      xCam = 768;
    }
    if (yCam < 0)
    {
      yCam = 0;
    }
    if (yCam > 256)
    {
      yCam = 256;
    }
    //Level and Gamemode Logic
    if (menu.choicerGM(gamemode) == false)
    {
      leveltimer = 23999;
      p1.gaffyLogic();
      p1.xPos = 48;
      p1.yPos = 172;
      p1.dir = 1;
      p1.Render();
      menu.keyHandler();
      menu.choicerCredits();
      menu.choicerLevel();
      //menu.choicerGM(gamemode);
      menu.Render();
    }
    if (menu.choicerGM(gamemode) == true)
    {
      title.stop();
      //Level-Specific calls
      if (levelID == 1)
      {

        translate((-xCam)*3, (-yCam)*3);

        p1.gaffyLogic();
        l1.Render();
        boulder.Render();
        p1.Render();
        translate((xCam)*3, (yCam)*3);
      }
      if (levelID == 2)
      {
        if (init ==false)
          levelClear = false;
        init =  true;
        translate((-xCam)*3, (-yCam)*3);
        p1.gaffyLogic();
        l2.Render();
        p1.Render();
        translate((xCam)*3, (yCam)*3);
      }
      if (levelID == 3)
      {

        translate((-xCam)*3, (-yCam)*3);
        p1.gaffyLogic();
        l3.Render();
        p1.Render();
        translate((xCam)*3, (yCam)*3);
      }
      //Common Rendering: HUD
      hud.levelID = levelID;
      hud.Render();
    }
    if (menu.isDebug == true)
    {
      textAlign(LEFT, TOP);
      fill(255);
      text(nf(frameRate, 3, 1)+"fps", -8*d, 216*d);
    }
  }
}
class SoundSetup
{
  SoundSetup()
  {
    
  }
  public void Setup()
  {

  }
}


  public void settings() { size(768, 672); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "GaffyGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
